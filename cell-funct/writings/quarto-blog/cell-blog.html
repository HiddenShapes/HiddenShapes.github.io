<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.340">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Leonard Hardiman">

<title>A Categorical approach to cellular automata</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="cell-blog_files/libs/clipboard/clipboard.min.js"></script>
<script src="cell-blog_files/libs/quarto-html/quarto.js"></script>
<script src="cell-blog_files/libs/quarto-html/popper.min.js"></script>
<script src="cell-blog_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="cell-blog_files/libs/quarto-html/anchor.min.js"></script>
<link href="cell-blog_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="cell-blog_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="cell-blog_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="cell-blog_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="cell-blog_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="cell-blog_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="cell-blog_files/libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
</head><body>$$
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\Mod}{Mod}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\Aut}{Aut}
\DeclareMathOperator{\Obj}{Obj}
\DeclareMathOperator{\Id}{Id}
\DeclareMathOperator{\Sym}{Sym}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\Cell}{\underline{\mathbb{C}\!ell}}
\DeclareMathOperator{\Support}{Supp}
\DeclareMathOperator{\sh}{sh}
\DeclareMathOperator{\conf}{conf}
\DeclareMathOperator{\poz}{\overset{\circ}{\times}}
\DeclareMathOperator{\span}{span}
\DeclareMathOperator{\length}{length}
\newcommand{\de}{\delta}
\newcommand{\bC}{\mathbb{C}}
\newcommand{\bG}{\mathbb{G}}
\newcommand{\bN}{\mathbb{N}}
\newcommand{\bZ}{\mathbb{Z}}
\newcommand{\com}[1]{{\color{red}\textbf{#1}}}
\newcommand{\supp}[2]{\Support_{#1}(#2)}
$$

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="custom.css">




<div id="quarto-content" class="page-columns page-rows-contents page-layout-full toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#context" id="toc-context" class="nav-link active" data-scroll-target="#context">Context</a>
  <ul class="collapse">
  <li><a href="#brief-introduction-to-cellular-automata" id="toc-brief-introduction-to-cellular-automata" class="nav-link" data-scroll-target="#brief-introduction-to-cellular-automata">Brief introduction to cellular automata</a></li>
  </ul></li>
  <li><a href="#categorical-foundations" id="toc-categorical-foundations" class="nav-link" data-scroll-target="#categorical-foundations">Categorical foundations</a>
  <ul class="collapse">
  <li><a href="#realising-a-dynamical-system-as-a-category" id="toc-realising-a-dynamical-system-as-a-category" class="nav-link" data-scroll-target="#realising-a-dynamical-system-as-a-category">Realising a dynamical system as a category</a>
  <ul class="collapse">
  <li><a href="#initial-incorrect-construction" id="toc-initial-incorrect-construction" class="nav-link" data-scroll-target="#initial-incorrect-construction">Initial (incorrect) construction</a></li>
  <li><a href="#the-improved-construction" id="toc-the-improved-construction" class="nav-link" data-scroll-target="#the-improved-construction">The improved construction</a></li>
  </ul></li>
  <li><a href="#the-2-category-of-cellular-automata-cell" id="toc-the-2-category-of-cellular-automata-cell" class="nav-link" data-scroll-target="#the-2-category-of-cellular-automata-cell">The 2-category of cellular automata <span class="math inline">\(\Cell\)</span></a>
  <ul class="collapse">
  <li><a href="#translation-invariance" id="toc-translation-invariance" class="nav-link" data-scroll-target="#translation-invariance">Translation invariance</a></li>
  <li><a href="#local-rules" id="toc-local-rules" class="nav-link" data-scroll-target="#local-rules">Local rules</a></li>
  </ul></li>
  <li><a href="#zero-ca" id="toc-zero-ca" class="nav-link" data-scroll-target="#zero-ca">Zero CA</a></li>
  </ul></li>
  <li><a href="#various-functors" id="toc-various-functors" class="nav-link" data-scroll-target="#various-functors">Various Functors</a>
  <ul class="collapse">
  <li><a href="#local-functors" id="toc-local-functors" class="nav-link" data-scroll-target="#local-functors">Local functors</a></li>
  <li><a href="#formal-trivial-functors" id="toc-formal-trivial-functors" class="nav-link" data-scroll-target="#formal-trivial-functors">Formal trivial functors</a></li>
  <li><a href="#isomorphisms" id="toc-isomorphisms" class="nav-link" data-scroll-target="#isomorphisms">Isomorphisms</a></li>
  <li><a href="#equivalences" id="toc-equivalences" class="nav-link" data-scroll-target="#equivalences">Equivalences</a>
  <ul class="collapse">
  <li><a href="#rooted-paths" id="toc-rooted-paths" class="nav-link" data-scroll-target="#rooted-paths">Rooted paths</a></li>
  <li><a href="#collapsing-onto-a-path" id="toc-collapsing-onto-a-path" class="nav-link" data-scroll-target="#collapsing-onto-a-path">Collapsing onto a path</a></li>
  <li><a href="#a-more-general-example" id="toc-a-more-general-example" class="nav-link" data-scroll-target="#a-more-general-example">A more general example</a></li>
  </ul></li>
  <li><a href="#projection-deformation-retracts" id="toc-projection-deformation-retracts" class="nav-link" data-scroll-target="#projection-deformation-retracts">Projection / Deformation retracts</a></li>
  </ul></li>
  <li><a href="#endomorphisms-of-cell" id="toc-endomorphisms-of-cell" class="nav-link" data-scroll-target="#endomorphisms-of-cell">Endomorphisms of <span class="math inline">\(\Cell\)</span></a>
  <ul class="collapse">
  <li><a href="#zoom-out" id="toc-zoom-out" class="nav-link" data-scroll-target="#zoom-out">Zoom out</a></li>
  <li><a href="#section" id="toc-section" class="nav-link" data-scroll-target="#section">?</a></li>
  </ul></li>
  <li><a href="#life-preserving" id="toc-life-preserving" class="nav-link" data-scroll-target="#life-preserving">Life preserving</a>
  <ul class="collapse">
  <li><a href="#product-of-cas-over-0" id="toc-product-of-cas-over-0" class="nav-link" data-scroll-target="#product-of-cas-over-0">Product of CAs over 0</a></li>
  <li><a href="#shadows-and-support" id="toc-shadows-and-support" class="nav-link" data-scroll-target="#shadows-and-support">Shadows and support</a></li>
  <li><a href="#superfluous-states" id="toc-superfluous-states" class="nav-link" data-scroll-target="#superfluous-states">Superfluous states</a></li>
  <li><a href="#life-equivalence" id="toc-life-equivalence" class="nav-link" data-scroll-target="#life-equivalence">Life equivalence</a></li>
  </ul></li>
  <li><a href="#representation-theory" id="toc-representation-theory" class="nav-link" data-scroll-target="#representation-theory">Representation theory</a></li>
  <li><a href="#questions" id="toc-questions" class="nav-link" data-scroll-target="#questions">Questions</a></li>
  <li><a href="#other-ideas" id="toc-other-ideas" class="nav-link" data-scroll-target="#other-ideas">Other ideas</a></li>
  <li><a href="#clement-ideas" id="toc-clement-ideas" class="nav-link" data-scroll-target="#clement-ideas">Clement ideas</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content column-page-right" id="quarto-document-content">
<script type="module" src="./javascript/cellularAutomaton.js"></script>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">A Categorical approach to cellular automata</h1>
<p class="subtitle lead">or CA with CT</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Leonard Hardiman </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<p>This is a “living document” to track work on various aspects of cellular automata.</p>
<section id="context" class="level1">
<h1>Context</h1>
<section id="brief-introduction-to-cellular-automata" class="level2">
<h2 class="anchored" data-anchor-id="brief-introduction-to-cellular-automata">Brief introduction to cellular automata</h2>
<p>Let <span class="math inline">\(S\)</span> be a non-empty finite set of states and let <span class="math inline">\(G\)</span> be an non-empty graph. We also consider a distinguished state <span class="math inline">\(0 \in S\)</span>, called the <em>dead</em> state. A <em>Cellular Automaton</em> (CA) on <span class="math inline">\(G\)</span> is a function, <span class="math display">\[\de \colon S^{V} \rightarrow S^{V},\]</span> where <span class="math inline">\(V\)</span> denotes the set of vertices in <span class="math inline">\(G\)</span>. We call an element of <span class="math inline">\(S^{V}\)</span> a <em>configuration</em>, and call this function the <em>transition function</em>, it describes the dynamics of the automaton, mapping the current configuration (state of each vertex) to the next configuration.</p>
<p>Obviously, <span class="math inline">\(\de\)</span> should be constrained by <span class="math inline">\(G\)</span>, in some way. But, for now, one of the good/bad things is that everything works for an arbitrary <span class="math inline">\(\de \in \End(S^{V})\)</span>. Here is a list of properties that <span class="math inline">\(\delta\)</span> will have that probably should be brought into the story:</p>
<ul>
<li>translation invariance (requires elements of <span class="math inline">\(G\)</span> to have a <span class="math inline">\(\bZ^n\)</span>-action),</li>
<li>dead cells do nothing by themselves + product over death should be a product</li>
<li>local rules.</li>
</ul>
</section>
</section>
<section id="categorical-foundations" class="level1">
<h1>Categorical foundations</h1>
<section id="realising-a-dynamical-system-as-a-category" class="level2">
<h2 class="anchored" data-anchor-id="realising-a-dynamical-system-as-a-category">Realising a dynamical system as a category</h2>
<section id="initial-incorrect-construction" class="level3">
<h3 class="anchored" data-anchor-id="initial-incorrect-construction">Initial (incorrect) construction</h3>
<p>An initial attempt to realise a cellular automaton as a category <span class="math inline">\(\bC\)</span> might go as follows,</p>
<ul>
<li><span class="math inline">\(\Obj(\bC) = S^{V}\)</span> (i.e.&nbsp;the configurations)</li>
<li><span class="math inline">\(\Hom(a,b) = \{n \in \bN \mid \de^n(a)=b \}.\)</span></li>
</ul>
<p>A nice feature of this construction is that composition is simply given by addition. In particular, the identity map is given by <span class="math inline">\(0 \colon a \to a\)</span>, we denote this map <span class="math inline">\(\id \in \End(a)\)</span>. In the subsequent discussion, we confuse any given CA with its associated category.</p>
<p>We note that the <span class="math inline">\(\Hom\)</span>-spaces have a fairly particular structure; for <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> be such that <span class="math inline">\(\Hom(a,b) \neq \emptyset\)</span> there exists <span class="math inline">\(k, l \in \bN\)</span> such that <span class="math display">\[
\Hom(a,b) =
\begin{cases}
\{ k \} &amp; \text{if neither $a$ nor $b$ are recurrent.}\\
\{k + n\cdot l \mid n \in \bN\} &amp;\text{else.}
\end{cases}
\]</span></p>
<p>Our real object of interest is the 2-category <span class="math inline">\(\Cell\)</span> of such categories (i.e.&nbsp;categories that arise from cellular automata). In particular, we’re interested in finding non-trivial functors <span class="math inline">\(F \colon \bC_1 \to \bC_2\)</span>. However this is where are current construction of <span class="math inline">\(\bC\)</span> will fail us.</p>
</section>
<section id="the-improved-construction" class="level3">
<h3 class="anchored" data-anchor-id="the-improved-construction">The improved construction</h3>
<p>Quotient by the equivalence relation <span class="math inline">\((n,m) \sim (o,p)\)</span> if <span class="math inline">\(\exists k \in \mathbb{Z}\)</span> such that <span class="math inline">\((o,p) = (n+k,m+k)\)</span>.</p>
<p>An initial challenge in answering this question is finding the right characterisation of “trivial”. This is one of the objectives of the next section.</p>
<div id="lem-describeHomSets" class="theorem lemma theorem lemma">
<p><span class="theorem-title"><strong>Lemma 1 </strong></span><span class="math inline">\(\com{Describe the Hom-sets.}\)</span></p>
</div>
</section>
</section>
<section id="the-2-category-of-cellular-automata-cell" class="level2">
<h2 class="anchored" data-anchor-id="the-2-category-of-cellular-automata-cell">The 2-category of cellular automata <span class="math inline">\(\Cell\)</span></h2>
<section id="translation-invariance" class="level3">
<h3 class="anchored" data-anchor-id="translation-invariance">Translation invariance</h3>
<ul>
<li>Easy</li>
</ul>
</section>
<section id="local-rules" class="level3">
<h3 class="anchored" data-anchor-id="local-rules">Local rules</h3>
<ul>
<li>define the ‘universal’ local CA, <span class="math inline">\(\mathcal{L}\)</span>. A CA <span class="math inline">\(\bC\)</span> is local if <span class="math inline">\(\exists L \colon \mathcal{L} \to \bC\)</span></li>
</ul>
</section>
</section>
<section id="zero-ca" class="level2">
<h2 class="anchored" data-anchor-id="zero-ca">Zero CA</h2>
<p>[…]</p>
</section>
</section>
<section id="various-functors" class="level1">
<h1>Various Functors</h1>
<p>To recall a functor <span class="math inline">\(F\colon \bC_1 \to \bC_2\)</span> would consist of the following data,</p>
<ul>
<li>a map on configurations <span class="math inline">\(F \colon \Obj(\bC_1) \to \Obj(\bC_2)\)</span>,</li>
<li>a map on morphisms <span class="math inline">\(F \colon \Hom(a,b) \to \Hom(F(a),F(b))\)</span> such that <span class="math inline">\(F(\alpha + \beta) = F(\alpha) + F(\beta)\)</span>.</li>
</ul>
<p>From now on, we will always assume that this map is the identity (an assumption which implies that <span class="math inline">\(\Hom(a,b) = \Hom(F(a),F(b)), \ \forall a,b\)</span>).<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>As we have fixed the behaviour of the functor on morphisms, any mapping <span class="math inline">\(F\colon \Obj(\bC_1) \to \Obj(\bC_2)\)</span> provides a candidate functor, which gives rise to a genuine functor if the following diagram is satisfied,</p>
<div style="display: flex; justify-content: center;">
<div style="margin-right: 120px;">
<p><img class="myImage" src="./img/tikz/cd1.svg" style="width: 180%;"></p>
</div>
</div>
<p>Therefore, to represent these functors in a engaging way, we’ll present dynamic illustrations of this commutation at work, in the following style.</p>
<div style="display: flex; align-items: center; justify-content: center;">
<div style="text-align: right; margin-right: 30px;">
<p><span class="math inline">\(F \colon\)</span></p>
</div>
<div class="flex-container" style="display: flex; flex-direction: row; align-items: center;">
<div id="aCanvasContainer" class="canvasContainer">
<div id="wrapper4" class="canvas-wrapper">
<canvas id="aCanvas4" width="200" height="200">
</canvas>
</div>
<div id="wrapper1" class="canvas-wrapper">
<canvas id="aCanvas1" width="200" height="200">
</canvas>
</div>
<div id="wrapper5" class="canvas-wrapper">
<canvas id="aCanvas5" width="200" height="200">
</canvas>
</div>
<div id="wrapper3" class="canvas-wrapper">
<div class="overlay-container">
<canvas class="canvas-overlay" id="aCanvas3" width="200" height="200">
</canvas>
<canvas class="canvas-overlay" id="aCanvas2" width="200" height="200">
</canvas>
</div>
</div>
</div>
</div>
</div>
<div class="buttonContainer" style="padding-left: 50px;">
<button class="playButton" id="aPlayButton">
Play/Pause
</button>
</div>
<p>Here the blue arrows represent an increment in time (i.e.&nbsp;a morphism in <span class="math inline">\(\bC\)</span>) and the red arrows represent the functor in question. You can click on the diagram to increment all the CAs by one (you could think of each of the pictures being moved to the left), or you can simply press the play/pause button to toggle the passage of time on and off. Also the bottom right CA is in fact an overlay of two separate semi-transparent CAs, the first being calculated by incrementing the bottom left CA, and the second by applying the functor to the top right CA. Therefore, the fact that this overlay appears as a single unified CA testifies to the fact that the red arrow represent a functor.</p>
<p>Of course, this presentation is hard to parse without knowing the functor depicted. In this case, the functor serves principally to illustrate that relatively simple functors don’t necessarily appear so. We recommend finishing this section before attempting the following exercise.</p>
<p><strong>Exercise.</strong> Determine the functor <span class="math inline">\(F\)</span> depicted in the diagram above.</p>
<section id="local-functors" class="level2">
<h2 class="anchored" data-anchor-id="local-functors">Local functors</h2>
<p>Let <span class="math inline">\(\bC_1\)</span> and <span class="math inline">\(\bC_2\)</span> be two CAs on the same graph with states <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> respectively. A functor <span class="math inline">\(F \colon \bC_1 \to \bC_2\)</span> is called <em>local</em> if there exists a map <span class="math inline">\(f \colon S_1 \to S_2\)</span> that induces <span class="math inline">\(F\)</span>. <span class="math inline">\(\com{This could be a bad name.}\)</span></p>
</section>
<section id="formal-trivial-functors" class="level2">
<h2 class="anchored" data-anchor-id="formal-trivial-functors">Formal trivial functors</h2>
<p>Before proceeding, we note the existence of two “formal” examples of trivial functors: <span class="math display">\[
\textbf{0} \colon \bC \to \bot \quad \text{and} \quad \Id \colon \bC \to \bC,
\]</span> which we have depicted below.</p>
<div class="flex-container" style="display: flex; align-items: center;">
<span class="math inline">\(\textbf{0} \colon\)</span>
<div id="bCanvasContainer" class="canvasContainer">
<div id="wrapper4" class="canvas-wrapper">
<canvas id="bCanvas4" width="200" height="200">
</canvas>
</div>
<div id="wrapper1" class="canvas-wrapper">
<canvas id="bCanvas1" width="200" height="200">
</canvas>
</div>
<div id="wrapper5" class="canvas-wrapper">
<canvas id="bCanvas5" width="200" height="200">
</canvas>
</div>
<div id="wrapper3" class="canvas-wrapper">
<div class="overlay-container">
<canvas class="canvas-overlay" id="bCanvas3" width="200" height="200">
</canvas>
<canvas class="canvas-overlay" id="bCanvas2" width="200" height="200">
</canvas>
</div>
</div>
</div>
<span class="math inline">\(\Id \colon\)</span>
<div id="cCanvasContainer" class="canvasContainer">
<div id="wrapper4" class="canvas-wrapper">
<canvas id="cCanvas4" width="200" height="200">
</canvas>
</div>
<div id="wrapper1" class="canvas-wrapper">
<canvas id="cCanvas1" width="200" height="200">
</canvas>
</div>
<div id="wrapper5" class="canvas-wrapper">
<canvas id="cCanvas5" width="200" height="200">
</canvas>
</div>
<div id="wrapper3" class="canvas-wrapper">
<div class="overlay-container">
<canvas class="canvas-overlay" id="cCanvas3" width="200" height="200">
</canvas>
<canvas class="canvas-overlay" id="cCanvas2" width="200" height="200">
</canvas>
</div>
</div>
</div>
</div>
<div class="buttonContainer" style="padding-left: 20px;">
<button class="playButton" id="bPlayButton">
Play/Pause
</button>
</div>
</section>
<section id="isomorphisms" class="level2">
<h2 class="anchored" data-anchor-id="isomorphisms">Isomorphisms</h2>
</section>
<section id="equivalences" class="level2">
<h2 class="anchored" data-anchor-id="equivalences">Equivalences</h2>
<p>In category theory, the concept of “sameness” is not best captured by requiring the existence of isomorphism, but rather an <em>equivalence</em>. We recall that an equivalence is a functor <span class="math inline">\(F \colon \bC_1 \to \bC_2\)</span> such that there exists a functor <span class="math inline">\(G \colon \bC_1 \to \bC_2\)</span> which satisfies <span class="math inline">\(G \circ F \cong \id_{\bC_1}\)</span> and <span class="math inline">\(F \circ G \cong \id_{\bC_2}\)</span>. Such a <span class="math inline">\(G\)</span> is called an <em>inverse</em> to <span class="math inline">\(F\)</span> and is unique up to isomorphism.</p>
<p>Clearly, any isomorphisms from the previous question are equivalences. However, there is at least one important class of equivalences that are not isomorphims.</p>
<section id="rooted-paths" class="level3">
<h3 class="anchored" data-anchor-id="rooted-paths">Rooted paths</h3>
<p>Let <span class="math inline">\(\bC\)</span> be a CA together with a chosen configuration <span class="math inline">\(a_0 \in \Obj(\bC)\)</span>. For <span class="math inline">\(i \in \mathbb{N}\)</span> we consider the following sets <span class="math display">\[
\begin{aligned}
P_i &amp;= \{a \in \Obj(\bC) \mid \de^i(a) = a_0\}\\
P &amp;= \bigcup_i P_i.
\end{aligned}
\]</span> We call a sequence <span class="math inline">\((\pi_k) \in (P \sqcup \{\theta\})^{\bN}\)</span> an <em><span class="math inline">\(a_0\)</span>-rooted path</em> if</p>
<ol type="A">
<li><span class="math inline">\(\pi_0 = a_0\)</span>,</li>
<li><span class="math inline">\(\pi_k = \theta\)</span> if and only if <span class="math inline">\(P_k=\emptyset\)</span>,</li>
<li><span class="math inline">\(\de(\pi_k) = \pi_{k-1}\)</span>,</li>
<li><span class="math inline">\(\length(\pi)\)</span> is maximal with respect to all sequences satisfying the three properties above,</li>
</ol>
<p>where <span class="math inline">\(\length(\pi) = \sum_{k} \delta_{\pi_k \neq \theta}\)</span> (which may be infinite).</p>
</section>
<section id="collapsing-onto-a-path" class="level3">
<h3 class="anchored" data-anchor-id="collapsing-onto-a-path">Collapsing onto a path</h3>
<p>Let <span class="math inline">\(\bC\)</span> and <span class="math inline">\(a_0\)</span> be as before, and let <span class="math inline">\((\pi_k)\)</span> be an <span class="math inline">\(a_0\)</span>-rooted path. For every <span class="math inline">\(a\in P\)</span>, let <span class="math inline">\(k(a)\)</span> be the minimum integer such that <span class="math inline">\(a \in P_{k(a)}\)</span>. We consider the following map, <span class="math display">\[
\begin{aligned}
F \colon \Obj(\bC) &amp;\to \Obj(\bC)\\
a &amp;\mapsto
\begin{cases}
\pi_{k(a)} &amp;\text{if $a \in A$}\\
a &amp;\text{else.}
\end{cases}
\end{aligned}
\]</span></p>
<div id="prp-Fextends" class="theorem proposition theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1 </strong></span>Let <span class="math inline">\(F\)</span> be given as above. Then <span class="math inline">\(F\)</span> extends to a functor in <span class="math inline">\(\End(\bC)\)</span>.<br> <em>Proof.</em> We have that</p>
<div style="display: flex; justify-content: center; margin-top: -20px; clear: both;">
<div style="margin-right: 120px;">
<p><img class="myImage" src="./img/tikz/cd1-np.svg" style="width: 180%;"></p>
</div>
</div>
<p>clearly commutes when <span class="math inline">\(F(a) = a\)</span> and <span class="math inline">\(F(b) = b\)</span>. If <span class="math inline">\(F(a) \neq a\)</span> and <span class="math inline">\(F(b) \neq b,\)</span> then the diagram commutes by Property (C), the only case where <span class="math inline">\(F(a) \neq a\)</span> and <span class="math inline">\(F(b) = b\)</span> is when <span class="math inline">\(a \in P_1\)</span> and <span class="math inline">\(b = a_0\)</span> which implies that diagram commutes, the final case, when <span class="math inline">\(F(a) = a\)</span> and <span class="math inline">\(F(b) \neq b\)</span> never occurs by Property (D). <span class="end-proof"><span class="math inline">\(\blacksquare\)</span></span></p>
</div>
<div id="fig-collapse" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="./img/tikz/rootedPath.svg" class="img-fluid figure-img" width="200"></p>
<figcaption class="figure-caption">Figure&nbsp;1: The shaded region represents <span class="math inline">\(A(a_0)\)</span>, the vertical axis tracks <span class="math inline">\(k\)</span> (this figure assumes <span class="math inline">\(a_0\)</span> is not recurrent) which corresponds to ‘backwards time’ from the cellular point of view. The functor from <a href="#prp-Fextends">Proposition&nbsp;1</a> collapses <span class="math inline">\(A_k(a_0)\)</span> horizontally onto <span class="math inline">\((\pi_k)\)</span>, the functor from <a href="#prp-Gextends">Proposition&nbsp;2</a> applies an arbitrary endomorphism to each horizontal slice of <span class="math inline">\(A_k(a_0)\)</span>.</figcaption>
</figure>
</div>
</section>
<section id="a-more-general-example" class="level3">
<h3 class="anchored" data-anchor-id="a-more-general-example">A more general example</h3>
<p>The examples above suggest the following, more general, construction. We consider a family of endomorphisms <span class="math inline">\((\sigma_k) \in \End(A_k)^{\bZ}\)</span> with the property that <span class="math display">\[
\de(\sigma_k(a)) = \sigma_{k-1}(\de(a)).
\]</span></p>
<p>We then consider the following map, <span class="math display">\[
\begin{aligned}
G \colon \Obj(\bC) &amp;\to \Obj(\bC)\\
a &amp;\mapsto
\begin{cases}
\sigma_{k(a)}(a) &amp;\text{if $a \in A$}\\
a &amp;\text{else.}
\end{cases}
\end{aligned}
\]</span></p>
<p>The proof given for <a href="#prp-Fextends">Proposition&nbsp;1</a> also proves the following stronger result.</p>
<div id="prp-Gextends" class="theorem proposition theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2 </strong></span>Let <span class="math inline">\(G\)</span> be given as above. <span class="math inline">\(G\)</span> extends to a functor in <span class="math inline">\(\End(\bC)\)</span>.</p>
</div>
<p>An important property of the categorical structure in which we have embedded our cellular automata, is that <span class="math inline">\(G\)</span> is an equivalence.</p>
<div id="prp-Gequivalence" class="theorem proposition theorem proposition">
<p><span class="theorem-title"><strong>Proposition 3 </strong></span>Let <span class="math inline">\(G\)</span> be given as above. Then <span class="math inline">\(G \cong \id_{\bC}\)</span>.<br> <em>Proof.</em> We construct a natural isomorphism <span class="math inline">\(\Phi \colon G \to \id\)</span> as follows, <span class="math display">\[
\Phi(a) = \begin{cases} \left(\alpha_a \ \colon G(a) \to a\right) &amp; \text{if $a \in P,$}\\ (\id_a \colon G(a) \to a) &amp; \text{else,} \end{cases}
\]</span> where <span class="math inline">\(\alpha_a = (k(a),k(a)) \in \Hom(\sigma_{k(a)}(a),a)\)</span>; this morphism exists as both <span class="math inline">\(a\)</span> and <span class="math inline">\(\sigma_{k(a)}(a)\)</span> are in <span class="math inline">\(P_{k(a)}\)</span>, implying <span class="math inline">\(\de^{k(a)}(a) = \de^{k(a)}(\sigma_{k(a)}(a)) = a_0\)</span>. To check that <span class="math inline">\(\Phi\)</span> is natural we only have to check that, for <span class="math inline">\((n,m) \in \Hom(a,b)\)</span>, the following diagram commutes,</p>
<div style="display: flex; justify-content: center; margin-top: -20px; clear: both;">
<div style="margin-right: 120px;">
<p><img class="myImage" src="./img/tikz/cd2.svg" style="width: 180%;"></p>
</div>
</div>
<p>As is often the case in <span class="math inline">\(\bC\)</span>, once the diagram has been established, it is easy to see that it commputes (due to <span class="math inline">\(\bC\)</span> not having many morphisms, see <a href="#lem-describeHomSets">Lemma&nbsp;1</a>). For instance, the case when <span class="math inline">\(a,b \in P\)</span> can be verified by considering the following figure,</p>
<div id="fig-collapse" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="./img/tikz/diagram1.svg" class="img-fluid figure-img" width="200"></p>
<figcaption class="figure-caption">Figure&nbsp;2: A structural representation of the case when <span class="math inline">\(a,b \in P\)</span>. We can see that both the upper-right and lower-left compositions in <span class="math inline">\(\mathcal{D}\)</span> give the red span from <span class="math inline">\(G(a)\)</span> to <span class="math inline">\(b\)</span>.</figcaption>
</figure>
</div>
<p>The other cases may be verified analogously. <span class="end-proof"><span class="math inline">\(\blacksquare\)</span></span></p>
</div>
</section>
</section>
<section id="projection-deformation-retracts" class="level2">
<h2 class="anchored" data-anchor-id="projection-deformation-retracts">Projection / Deformation retracts</h2>
<ul>
<li>Superfluous states of life … ok</li>
<li>Superfluous states of death … less ok</li>
</ul>
</section>
</section>
<section id="endomorphisms-of-cell" class="level1">
<h1>Endomorphisms of <span class="math inline">\(\Cell\)</span></h1>
<section id="zoom-out" class="level2">
<h2 class="anchored" data-anchor-id="zoom-out">Zoom out</h2>
</section>
<section id="section" class="level2">
<h2 class="anchored" data-anchor-id="section">?</h2>
</section>
</section>
<section id="life-preserving" class="level1">
<h1>Life preserving</h1>
<section id="product-of-cas-over-0" class="level2">
<h2 class="anchored" data-anchor-id="product-of-cas-over-0">Product of CAs over 0</h2>
<p>Let <span class="math inline">\(\bC_1\)</span> and <span class="math inline">\(\bC_2\)</span> be two cellular automata on a graph <span class="math inline">\(G\)</span> with states <span class="math inline">\(S_1,S_2\)</span> and transition functions <span class="math inline">\(\de_1,\de_2\)</span> respectively. Their direct product (over 0) is a CA on <span class="math inline">\(G\)</span> denotes <span class="math inline">\(\bC_1 \poz \bC_2\)</span> with states <span class="math display">\[
S = S_1 \times S_2 / \langle (0,n) \sim (m,0) \mid \forall n \in S_1, m \in S_2 \rangle.
\]</span> and transition function <span class="math display">\[
\de(c)(i,j) = (\de_1(c_1), \de_2(c_2)),
\]</span> where <span class="math inline">\(c_1\)</span> and <span class="math inline">\(c_2\)</span> are the natural projections of the configuration <span class="math inline">\(c \in S^V\)</span> into <span class="math inline">\(S_1^V\)</span> and <span class="math inline">\(S_2^V\)</span> respectively.</p>
<p><strong>Note:</strong> Vassilis gives the following intuition: ‘the two CAs can only interact through death’. This is correct.</p>
<p><strong>Clue:</strong> This construction should give some kind of product in <span class="math inline">\(\Cell\)</span>, or <span class="math inline">\(\span(\Cell)\)</span>.</p>
<p><strong>Exercise:</strong> Let <span class="math inline">\(\bG\)</span> be Conway’s game of life. Show that <span class="math inline">\(\bG \poz \bG = \bG\)</span>.</p>
</section>
<section id="shadows-and-support" class="level2">
<h2 class="anchored" data-anchor-id="shadows-and-support">Shadows and support</h2>
<p>Let <span class="math inline">\(\bC\)</span> be a CA together with a configuration <span class="math inline">\(a \in \Obj(\bC) = S^V\)</span>. The <em>shadow of <span class="math inline">\(a\)</span></em> is defined as follows, <span class="math display">\[
\begin{aligned}\sh(a) \colon V &amp;\to \{0,1\} \\ v &amp;\mapsto \begin{cases}0 &amp; \text{if $a(v) =0,$} \\ 1 &amp; \text{else.}\end{cases} \end{aligned}
\]</span> The <em><span class="math inline">\(\bC\)</span>-support</em> of <span class="math inline">\(a\)</span> is then given by the function <span class="math display">\[
\begin{aligned}\supp{\bC}{a} : \bN &amp;\to \{0,1\}^V \\ i &amp;\mapsto \sh(\de^{i}(a)),\end{aligned}
\]</span> where <span class="math inline">\(\de\)</span> is the transition function of <span class="math inline">\(\bC\)</span>.</p>
<p><span class="math inline">\(\com{[todo: example]}\)</span></p>
<p>Let <span class="math inline">\(\bC_1\)</span> and <span class="math inline">\(\bC_2\)</span> be two CAs whose underlying graphs share the same set of vertices <span class="math inline">\(V\)</span>. A map (or functor) <span class="math inline">\(F \colon \Obj(\bC_1) \to \Obj(\bC_2)\)</span> is called <em>life preserving</em> if it satisfies <span class="math inline">\(\supp{\bC_2}{F(a)} = \supp{\bC_1}{a}\)</span>, <span class="math inline">\(\forall a \in \Obj(\bC_1)\)</span>.</p>
<p>We note that there exist life preserving maps that are not functors. To construct an example, we consider the following new concept.</p>
</section>
<section id="superfluous-states" class="level2">
<h2 class="anchored" data-anchor-id="superfluous-states">Superfluous states</h2>
<p>Let <span class="math inline">\(\bC\)</span> be a CA with states <span class="math inline">\(S\)</span> and let <span class="math inline">\(\bar{S}\)</span> be a subset of <span class="math inline">\(S\)</span>.</p>
<p>We call <span class="math inline">\(\bar{S}\)</span> <em>superfluous</em> if there exists a local life-preserving functor <span class="math inline">\(F\colon \bC \to \bar{\bC}\)</span>, where <span class="math inline">\(\bar{\bC}\)</span> is a CA with states <span class="math inline">\(S \setminus \bar{S}\)</span>. An example is provided by the following set up:</p>
<div id="supCanvasContainer" class="canvasContainer">
<div id="wrapper4" class="canvas-wrapper">
<canvas id="supCanvas4" width="200" height="200">
</canvas>
</div>
<div id="wrapper1" class="canvas-wrapper">
<canvas id="supCanvas1" width="200" height="200">
</canvas>
</div>
<div id="wrapper5" class="canvas-wrapper">
<canvas id="supCanvas5" width="200" height="200">
</canvas>
</div>
<div id="wrapper3" class="canvas-wrapper">
<div class="overlay-container">
<canvas id="supCanvas3" width="200" height="200">
</canvas>
<canvas id="supCanvas2" width="200" height="200">
</canvas>
</div>
</div>
</div>
<div class="buttonContainer">
<button class="playButton" id="supPlayButton">
Play/Pause
</button>
</div>
<p>The top CA is a simple ‘colouring’ of</p>
</section>
<section id="life-equivalence" class="level2">
<h2 class="anchored" data-anchor-id="life-equivalence">Life equivalence</h2>
</section>
</section>
<section id="representation-theory" class="level1">
<h1>Representation theory</h1>
<ul>
<li>The set of states are given by <span class="math inline">\(S = \Sym(k)\)</span> for some <span class="math inline">\(k \in \bN\)</span>.</li>
</ul>
</section>
<section id="questions" class="level1">
<h1>Questions</h1>
<ul>
<li>What is the smaller number of states needed for a CA to have a given support?</li>
<li>Is there a notion of the simplest/smallest CA that has a given support?</li>
<li>If <span class="math inline">\(\bC_{1}\)</span> and <span class="math inline">\(\bC_{2}\)</span> share a support, is there a functor between them? Or a span <span class="math inline">\(\bC_{1} \to \bC_{3} \leftarrow \bC_{2}\)</span>?</li>
</ul>
</section>
<section id="other-ideas" class="level1">
<h1>Other ideas</h1>
<ul>
<li>Take the product of two CAs over their dead states, in particular the dead states should be ‘compatible’</li>
<li>optimal CA universal prop?</li>
<li>inverse of a zoom out?</li>
<li>could convolution give a functor for some CA?</li>
</ul>
</section>
<section id="clement-ideas" class="level1">
<h1>Clement ideas</h1>
<ul>
<li>Measuring frustration (shadow rank)</li>
</ul>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>It would be perfectly possible to forgo this assumption, the cellular interpretation perhaps being some kind of “time dilation” (which could be very not trivial, depending upon the source and target configurations).<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->

<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>